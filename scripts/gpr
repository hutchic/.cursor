#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# vim: set ft=bash:
#
# gpr - Create or Update GitHub Pull Request
#
# Description:
#   Pushes the current branch and creates or updates a pull request on GitHub.
#   Works with either GitHub CLI (gh) or GitHub MCP.
#
# Usage:
#   gpr "feat(api): add search endpoint" [--snippet-mode MODE] [--snippet-path PATH] [--snippet-content CONTENT]
#
# Arguments:
#   PR_TITLE        Required. The semantic title for the pull request.
#   --snippet-mode  Optional. One of: auto, file, paste. Default: auto.
#   --snippet-path  Optional. File path for 'file' mode.
#   --snippet-content Optional. Content for 'paste' mode.
#
# Environment Variables:
#   GITHUB_TOKEN    Optional. GitHub token for authentication (used by gh CLI).
#
# Exit Codes:
#   0 - Success
#   1 - General error
#   2 - Invalid arguments
#   3 - Detached HEAD state
#   4 - Push failed
#   5 - No tool available (neither gh nor MCP)
#   6 - PR operation failed

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
SNIPPET_MODE="auto"
SNIPPET_PATH=""
SNIPPET_CONTENT=""
PR_TITLE=""

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

usage() {
    cat <<EOF
Usage: gpr "PR_TITLE" [OPTIONS]

Create or update a GitHub pull request for the current branch.

Arguments:
  PR_TITLE              The semantic title for the pull request (required)

Options:
  --snippet-mode MODE   Snippet mode: auto, file, paste (default: auto)
  --snippet-path PATH   File path when using 'file' mode
  --snippet-content TXT Content when using 'paste' mode
  -h, --help           Show this help message

Examples:
  gpr "feat(api): add search endpoint"
  gpr "fix(auth): resolve token expiry" --snippet-mode file --snippet-path src/auth.py
  gpr "docs: update README" --snippet-mode paste --snippet-content "See commit history"

EOF
}

# Parse arguments
parse_args() {
    # Check for help first
    for arg in "$@"; do
        if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
            usage
            exit 0
        fi
    done

    if [[ $# -eq 0 ]]; then
        log_error "PR title is required"
        usage
        exit 2
    fi

    PR_TITLE="$1"
    shift

    while [[ $# -gt 0 ]]; do
        case $1 in
            --snippet-mode)
                SNIPPET_MODE="$2"
                if [[ ! "$SNIPPET_MODE" =~ ^(auto|file|paste)$ ]]; then
                    log_error "Invalid snippet mode: $SNIPPET_MODE. Must be one of: auto, file, paste"
                    exit 2
                fi
                shift 2
                ;;
            --snippet-path)
                SNIPPET_PATH="$2"
                shift 2
                ;;
            --snippet-content)
                SNIPPET_CONTENT="$2"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                exit 2
                ;;
        esac
    done

    # Validate snippet mode requirements
    if [[ "$SNIPPET_MODE" == "file" && -z "$SNIPPET_PATH" ]]; then
        log_error "Snippet mode 'file' requires --snippet-path"
        exit 2
    fi

    if [[ "$SNIPPET_MODE" == "paste" && -z "$SNIPPET_CONTENT" ]]; then
        log_error "Snippet mode 'paste' requires --snippet-content"
        exit 2
    fi
}

# Check if HEAD is detached
check_detached_head() {
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

    if [[ "$branch" == "HEAD" ]]; then
        log_error "Detached HEAD state detected"
        log_error "Please run /gship or create a branch first"
        log_error "  git checkout -b <branch-name>"
        exit 3
    fi

    if [[ -z "$branch" ]]; then
        log_error "Unable to determine current branch"
        exit 3
    fi

    echo "$branch"
}

# Get repository information
get_repo_info() {
    local remote_url
    remote_url=$(git config --get remote.origin.url 2>/dev/null || echo "")

    if [[ -z "$remote_url" ]]; then
        log_error "No remote origin found"
        exit 1
    fi

    # Parse GitHub owner and repo from remote URL
    # Supports both SSH and HTTPS formats
    local owner repo
    if [[ "$remote_url" =~ github\.com[:/]([^/]+)/(.+)(\.git)?$ ]]; then
        owner="${BASH_REMATCH[1]}"
        repo="${BASH_REMATCH[2]%.git}"
    else
        log_error "Unable to parse GitHub repository from remote URL: $remote_url"
        exit 1
    fi

    echo "${owner}:${repo}"
}

# Push the current branch
push_branch() {
    local branch="$1"
    log_info "Pushing branch: $branch"

    # Check if upstream exists
    local upstream
    upstream=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null || echo "")

    if [[ -z "$upstream" ]]; then
        log_info "No upstream set, pushing with --set-upstream"
        if ! git push --set-upstream origin "$branch"; then
            log_error "Failed to push branch"
            exit 4
        fi
    else
        log_info "Pushing to existing upstream"
        if ! git push; then
            log_error "Failed to push branch"
            exit 4
        fi
    fi

    log_success "Branch pushed successfully"
}

# Check if gh CLI is available and authenticated
check_gh_cli() {
    if ! command -v gh &>/dev/null; then
        return 1
    fi

    if ! gh auth status &>/dev/null; then
        log_warning "gh CLI found but not authenticated"
        return 1
    fi

    return 0
}

# Check if GitHub MCP is available
check_github_mcp() {
    # This is a placeholder - in a real implementation, you would check
    # if the GitHub MCP server is available and configured
    # For now, we'll return false as MCP requires specific setup
    return 1
}

# Get commit log for PR body
get_commit_log() {
    local base_branch="${1:-main}"
    local commits

    # Try to get commits since base branch
    if git rev-parse --verify "origin/$base_branch" &>/dev/null; then
        commits=$(git log --pretty=format:"- %s (%h)" "origin/$base_branch..HEAD" 2>/dev/null || echo "")
    else
        # Fallback to last 10 commits if base branch not found
        commits=$(git log --pretty=format:"- %s (%h)" -n 10 2>/dev/null || echo "")
    fi

    if [[ -z "$commits" ]]; then
        echo "No commits found"
    else
        echo "$commits"
    fi
}

# Get diff stat for snippet
get_diff_stat() {
    local base_branch="${1:-main}"
    local stat

    if git rev-parse --verify "origin/$base_branch" &>/dev/null; then
        stat=$(git diff --stat "origin/$base_branch..HEAD" 2>/dev/null || echo "")
    else
        stat=$(git diff --stat HEAD~1..HEAD 2>/dev/null || echo "")
    fi

    if [[ -z "$stat" ]]; then
        echo "No changes detected"
    else
        echo "$stat"
    fi
}

# Get file content for snippet
get_file_snippet() {
    local file_path="$1"

    if [[ ! -f "$file_path" ]]; then
        log_error "File not found: $file_path"
        return 1
    fi

    # Get up to 20 lines of the file
    head -n 20 "$file_path"
}

# Generate snippet based on mode
generate_snippet() {
    local mode="$1"
    local base_branch="${2:-main}"

    case "$mode" in
        auto)
            echo '```'
            get_diff_stat "$base_branch"
            echo '```'
            ;;
        file)
            if [[ -n "$SNIPPET_PATH" ]]; then
                echo '```'
                get_file_snippet "$SNIPPET_PATH"
                echo '```'
            else
                echo "No file path provided"
            fi
            ;;
        paste)
            echo '```'
            echo "$SNIPPET_CONTENT"
            echo '```'
            ;;
    esac
}

# Generate PR body
generate_pr_body() {
    local base_branch="${1:-main}"

    cat <<EOF
## Summary

$PR_TITLE

## Changes

$(get_commit_log "$base_branch")

## Validation

- [ ] Code builds successfully
- [ ] Tests pass
- [ ] No linting errors
- [ ] Documentation updated (if applicable)

## Code Snippet

$(generate_snippet "$SNIPPET_MODE" "$base_branch")

## Risk Assessment

**Risk Level:** TBD

**Rollback Plan:** Revert this PR if issues are detected in production.

---

*Generated by gpr command*
EOF
}

# Find existing PR using gh CLI
find_pr_with_gh() {
    local branch="$1"
    local repo_info="$2"
    local owner="${repo_info%%:*}"
    local repo="${repo_info##*:}"

    # List PRs for the current branch
    local pr_number
    pr_number=$(gh pr list --head "$branch" --repo "$owner/$repo" --json number --jq '.[0].number' 2>/dev/null || echo "")

    echo "$pr_number"
}

# Create PR using gh CLI
create_pr_with_gh() {
    local title="$1"
    local body="$2"
    local base_branch="${3:-main}"
    local repo_info="$4"
    local owner="${repo_info%%:*}"
    local repo="${repo_info##*:}"

    log_info "Creating PR with gh CLI"

    local pr_url
    if pr_url=$(gh pr create \
        --title "$title" \
        --body "$body" \
        --base "$base_branch" \
        --repo "$owner/$repo" 2>&1); then
        log_success "PR created: $pr_url"
        log_success "(using gh)"
        return 0
    else
        log_error "Failed to create PR: $pr_url"
        return 1
    fi
}

# Update PR using gh CLI
update_pr_with_gh() {
    local pr_number="$1"
    local title="$2"
    local body="$3"
    local repo_info="$4"
    local owner="${repo_info%%:*}"
    local repo="${repo_info##*:}"

    log_info "Updating PR #$pr_number with gh CLI"

    if gh pr edit "$pr_number" \
        --title "$title" \
        --body "$body" \
        --repo "$owner/$repo" >/dev/null 2>&1; then

        local pr_url="https://github.com/$owner/$repo/pull/$pr_number"
        log_success "PR updated: $pr_url"
        log_success "(using gh)"
        return 0
    else
        log_error "Failed to update PR #$pr_number"
        return 1
    fi
}

# Main function
main() {
    parse_args "$@"

    log_info "Starting gpr command"
    log_info "PR Title: $PR_TITLE"

    # Check for detached HEAD
    local branch
    branch=$(check_detached_head)
    log_info "Current branch: $branch"

    # Get repository info
    local repo_info
    repo_info=$(get_repo_info)
    local owner="${repo_info%%:*}"
    local repo="${repo_info##*:}"
    log_info "Repository: $owner/$repo"

    # Push the branch
    push_branch "$branch"

    # Detect available tool
    local use_gh=false
    if check_gh_cli; then
        log_info "Using GitHub CLI (gh)"
        use_gh=true
    elif check_github_mcp; then
        log_info "Using GitHub MCP"
        log_error "GitHub MCP is not yet implemented in this script"
        exit 5
    else
        log_error "Neither GitHub CLI (gh) nor GitHub MCP is available"
        log_error ""
        log_error "Please install and authenticate with GitHub CLI:"
        log_error "  brew install gh  # macOS"
        log_error "  gh auth login"
        log_error ""
        log_error "Or configure GitHub MCP server"
        exit 5
    fi

    # Generate PR body
    local pr_body
    pr_body=$(generate_pr_body "main")

    if [[ "$use_gh" == true ]]; then
        # Check if PR exists
        local pr_number
        pr_number=$(find_pr_with_gh "$branch" "$repo_info")

        if [[ -n "$pr_number" ]]; then
            # Update existing PR
            if ! update_pr_with_gh "$pr_number" "$PR_TITLE" "$pr_body" "$repo_info"; then
                exit 6
            fi
        else
            # Create new PR
            if ! create_pr_with_gh "$PR_TITLE" "$pr_body" "main" "$repo_info"; then
                exit 6
            fi
        fi
    fi

    log_success "gpr completed successfully"
}

# Run main function
main "$@"
