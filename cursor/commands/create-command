#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# vim: ft=bash

#
# /create-command - Scaffold a New Cursor Command
#
# Creates a new Cursor IDE command with self-contained directory structure
# and proper documentation following repository best practices.
#
# USAGE:
#   create-command <name> [--description="..."]
#
# ARGUMENTS:
#   name          The command name (kebab-case, e.g., 'my-command')
#
# OPTIONS:
#   --description DESC  Brief description of the command
#   --help, -h          Show this help message
#
# EXAMPLES:
#   # Create a new command
#   create-command my-command --description="Does something useful"
#
#   # Create without description (will use default)
#   create-command another-command
#
# OUTPUT:
#   Creates self-contained command directory in cursor/commands/ with:
#   - commandname/commandname (executable script)
#   - commandname/README.md (documentation)
#   - commandname/lib/ (for helper modules)
#   - commandname/tests/ (for test suite)
#   - commandname/examples/ (for usage examples)
#   - Updates commands/README.md
#
# NOTES:
#   - Command names must use kebab-case (hyphens)
#   - All commands use directory structure (not standalone files)
#   - Minimum structure: executable + README.md
#   - Recommended: also add lib/, tests/, examples/ as needed
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Functions for colored output
print_error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_info() {
    echo -e "${BLUE}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

# Show help message
show_help() {
    sed -n '/^# \/create-command/,/^$/p' "$0" | sed 's/^# //'
}

# Validate command name
validate_name() {
    local name="$1"

    # Check if empty
    if [ -z "$name" ]; then
        print_error "Command name cannot be empty"
        return 1
    fi

    # Check format (kebab-case)
    if [[ ! "$name" =~ ^[a-z][a-z0-9-]*$ ]]; then
        print_error "Invalid command name: $name"
        echo "Command names must:"
        echo "  - Start with a lowercase letter"
        echo "  - Contain only lowercase letters, numbers, and hyphens"
        echo "  - Use kebab-case (e.g., 'my-command')"
        return 1
    fi

    # Check for reserved names
    case "$name" in
        help|test|commands|skills)
            print_error "Reserved command name: $name"
            return 1
            ;;
    esac

    return 0
}

# Create command directory structure
create_command_directory() {
    local name="$1"
    local description="$2"
    local commands_dir="$3"

    print_info "Creating directory command structure..."

    local cmd_dir="$commands_dir/$name"
    mkdir -p "$cmd_dir"/{lib,tests,examples}

    # Create main executable
    local cmd_file="$cmd_dir/$name"
    cat > "$cmd_file" << 'EOF'
#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# vim: ft=bash

#
# /COMMAND_NAME - BRIEF_DESCRIPTION
#
# Extended description of what this command does.
#
# USAGE:
#   COMMAND_NAME [options] [arguments]
#
# OPTIONS:
#   --help, -h    Show this help message
#
# EXAMPLES:
#   COMMAND_NAME
#

set -euo pipefail

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source helper modules
# source "$SCRIPT_DIR/lib/utils.sh"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_error() { echo -e "${RED}Error: $1${NC}" >&2; }
print_success() { echo -e "${GREEN}$1${NC}"; }
print_info() { echo -e "${BLUE}$1${NC}"; }
print_warning() { echo -e "${YELLOW}$1${NC}"; }

show_help() {
    sed -n '/^# \/COMMAND_NAME/,/^$/p' "$0" | sed 's/^# //'
}

main() {
    if [ $# -gt 0 ] && [[ "$1" =~ ^(-h|--help)$ ]]; then
        show_help
        exit 0
    fi

    print_info "Running COMMAND_NAME..."
    print_success "Command executed successfully!"
}

main "$@"
EOF

    sed -i "s/COMMAND_NAME/$name/g" "$cmd_file"
    sed -i "s/BRIEF_DESCRIPTION/$description/g" "$cmd_file"
    chmod +x "$cmd_file"
    print_success "✓ Created executable: $cmd_file"

    # Create README
    cat > "$cmd_dir/README.md" << EOF
# $name - $description

## Overview

Detailed description of the command.

## Usage

\`\`\`bash
$name [options] [arguments]
\`\`\`

## Features

- ✅ Feature 1
- ✅ Feature 2

## Architecture

This command uses the following structure:
- \`$name\`: Main executable
- \`lib/\`: Helper modules and utilities
- \`tests/\`: Test suite
- \`examples/\`: Usage examples

## Options

- \`--help, -h\`: Show help message

## Examples

See \`examples/\` directory for detailed examples.

## Development

### Adding New Features

1. Add helper functions to \`lib/\`
2. Update main executable to use them
3. Add tests in \`tests/\`
4. Update documentation

### Running Tests

\`\`\`bash
bash tests/test_$name.sh
\`\`\`

## Requirements

- Git
- Bash 4.0+

## Notes

- Important implementation details
EOF

    print_success "✓ Created README: $cmd_dir/README.md"

    # Create example helper module
    cat > "$cmd_dir/lib/utils.sh" << 'EOF'
#!/usr/bin/env bash
# Helper utilities for COMMAND_NAME

# Example utility function
validate_input() {
    local input="$1"
    [ -n "$input" ]
}
EOF

    sed -i "s/COMMAND_NAME/$name/g" "$cmd_dir/lib/utils.sh"
    print_success "✓ Created helper module: $cmd_dir/lib/utils.sh"

    # Create test file
    cat > "$cmd_dir/tests/test_$name.sh" << EOF
#!/usr/bin/env bash
# Tests for $name

set -euo pipefail

SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
CMD_DIR="\$(cd "\$SCRIPT_DIR/.." && pwd)"
CMD="\$CMD_DIR/$name"

test_count=0
pass_count=0

run_test() {
    local name="\$1"
    local command="\$2"

    test_count=\$((test_count + 1))
    echo "Test \$test_count: \$name"

    if eval "\$command"; then
        echo "✅ Pass"
        pass_count=\$((pass_count + 1))
    else
        echo "❌ Fail"
    fi
}

echo "Running tests for $name..."
echo ""

run_test "Help option" "\$CMD --help > /dev/null"
run_test "Basic execution" "\$CMD 2>&1 | grep -q 'successfully'"

echo ""
echo "Passed \$pass_count/\$test_count tests"
[ \$pass_count -eq \$test_count ]
EOF

    chmod +x "$cmd_dir/tests/test_$name.sh"
    print_success "✓ Created test file: $cmd_dir/tests/test_$name.sh"

    # Create example
    cat > "$cmd_dir/examples/basic.md" << EOF
# Basic Usage Example

\`\`\`bash
# Example 1: Basic usage
$name

# Example 2: With options
$name --option value
\`\`\`
EOF

    print_success "✓ Created example: $cmd_dir/examples/basic.md"
}

# Update commands README
update_readme() {
    local name="$1"
    local description="$2"
    local commands_dir="$3"
    local readme="$commands_dir/README.md"

    if [ ! -f "$readme" ]; then
        print_warning "README.md not found, skipping update"
        return
    fi

    # Check if command already documented
    if grep -q "### .*$name" "$readme"; then
        print_warning "Command '$name' already in README.md, skipping update"
        return
    fi

    print_info "Adding command to README.md..."

    # Create temp file with new entry
    local temp_file=$(mktemp)

    # Add entry before "## Meta Commands" section or append
    if grep -q "## Meta Commands" "$readme"; then
        awk -v name="$name" -v desc="$description" '
        /^## Meta Commands/ {
            print ""
            print "### `/" name "` - " desc
            print ""
            print "Brief description of the command."
            print ""
            print "**Usage:**"
            print ""
            print "```bash"
            print name " [options] [arguments]"
            print "```"
            print ""
            print "[Full Documentation](" name "/README.md)"
            print ""
        }
        { print }
        ' "$readme" > "$temp_file"
        mv "$temp_file" "$readme"
    else
        cat >> "$readme" << EOF

### \`/$name\` - $description

Brief description of the command.

**Usage:**

\`\`\`bash
$name [options] [arguments]
\`\`\`

[Full Documentation]($name/README.md)
EOF
    fi

    print_success "✓ Updated README.md"
}

# Main function
main() {
    # Parse arguments
    local name=""
    local description="Brief command description"

    while [ $# -gt 0 ]; do
        case "$1" in
            --help|-h)
                show_help
                exit 0
                ;;
            --description=*)
                description="${1#*=}"
                ;;
            -*)
                print_error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                if [ -z "$name" ]; then
                    name="$1"
                else
                    print_error "Unexpected argument: $1"
                    show_help
                    exit 1
                fi
                ;;
        esac
        shift
    done

    # Validate inputs
    if [ -z "$name" ]; then
        print_error "Command name is required"
        show_help
        exit 1
    fi

    if ! validate_name "$name"; then
        exit 1
    fi

    # Find commands directory
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local commands_dir

    # Check if we're in the commands directory
    if [[ "$script_dir" == */cursor/commands ]]; then
        commands_dir="$script_dir"
    # Check if cursor/commands exists relative to script
    elif [ -d "$script_dir/../commands" ]; then
        commands_dir="$(cd "$script_dir/../commands" && pwd)"
    # Check if we're in repository root
    elif [ -d "cursor/commands" ]; then
        commands_dir="$(cd cursor/commands && pwd)"
    else
        print_error "Could not find cursor/commands directory"
        exit 1
    fi

    # Check if command already exists
    if [ -f "$commands_dir/$name" ] || [ -d "$commands_dir/$name" ]; then
        print_error "Command '$name' already exists"
        exit 1
    fi

    # Create command
    echo ""
    print_info "Creating new command: $name"
    print_info "Structure: Self-contained directory"
    print_info "Description: $description"
    print_info "Location: $commands_dir"
    echo ""

    create_command_directory "$name" "$description" "$commands_dir"

    # Update README
    update_readme "$name" "$description" "$commands_dir"

    # Summary
    echo ""
    print_success "=== Command Created Successfully ==="
    echo ""
    print_info "Next steps:"
    echo "  1. Edit the command implementation in $commands_dir/$name/$name"
    echo "  2. Update the documentation in $commands_dir/$name/README.md"
    echo "  3. Test the command: $name --help"
    echo "  4. Add to git: git add cursor/commands/$name"
    echo ""
    echo "  Directory structure created:"
    echo "    - $commands_dir/$name/$name (executable)"
    echo "    - $commands_dir/$name/README.md (documentation)"
    echo "    - $commands_dir/$name/lib/ (helper modules)"
    echo "    - $commands_dir/$name/tests/ (test suite)"
    echo "    - $commands_dir/$name/examples/ (usage examples)"
    echo ""
    echo "  Add more as needed:"
    echo "    - Put helper functions in lib/"
    echo "    - Write tests in tests/"
    echo "    - Add examples in examples/"
    echo ""
}

main "$@"
