#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# vim: ft=sh

#
# /gadd - Smart Git Staging Command
#
# A guided and intelligent way to stage changes by logical groupings.
#
# USAGE:
#   gadd              # Guided mode: prompt for each bucket
#   gadd all          # Stage all modified files
#   gadd group=docs   # Stage only documentation files
#   gadd group=src    # Stage only source files
#   gadd group=tests  # Stage only test files
#   gadd group=deps   # Stage only dependency files
#   gadd group=ci     # Stage only CI files
#   gadd group=config # Stage only config files
#   gadd group=misc   # Stage only misc files
#
# DESCRIPTION:
#   This command stages files intelligently based on logical groupings:
#   - deps:   lockfiles, dependency manifests (package-lock.json, Gemfile.lock, etc.)
#   - src:    application/runtime code (*.py, *.js, *.java, *.go, etc.)
#   - tests:  test files and fixtures (test_*.py, *.test.js, __tests__/, etc.)
#   - docs:   README, docs, markdown (*.md, docs/, etc.)
#   - ci:     GitHub/GitLab configs, pipelines (.github/, .gitlab-ci.yml, etc.)
#   - config: yaml/json/toml/ini, docker, k8s, helm (*.yaml, Dockerfile, etc.)
#   - misc:   anything not matched by above buckets
#
# MODES:
#   - all:    Stage everything (git add -A)
#   - group:  Guided bucket-by-bucket (default)
#   - group=<bucket>: Stage only specified bucket
#
# SAFETY:
#   - Never commits or pushes
#   - Exits if conflicts or unmerged paths exist
#   - Exits if no changes exist
#
# OUTPUT:
#   After staging, shows:
#   - git diff --cached --stat
#   - git status --porcelain
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Parse command line arguments
MODE="group"
TARGET_BUCKET=""

if [ $# -gt 0 ]; then
    if [ "$1" = "all" ]; then
        MODE="all"
    elif [[ "$1" =~ ^group= ]]; then
        MODE="specific"
        TARGET_BUCKET="${1#group=}"
        # Validate bucket name
        if [[ ! "$TARGET_BUCKET" =~ ^(deps|src|tests|docs|ci|config|misc)$ ]]; then
            echo -e "${RED}Error: Invalid bucket name '$TARGET_BUCKET'${NC}"
            echo "Valid buckets: deps, src, tests, docs, ci, config, misc"
            exit 1
        fi
    else
        echo -e "${RED}Error: Invalid argument '$1'${NC}"
        echo "Usage: gadd [all|group=<bucket>]"
        exit 1
    fi
fi

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo -e "${RED}Error: Not in a git repository${NC}"
    exit 1
fi

# Get git status
STATUS_OUTPUT=$(git status --porcelain)

# Check if there are any changes
if [ -z "$STATUS_OUTPUT" ]; then
    echo -e "${YELLOW}No changes to stage${NC}"
    exit 0
fi

# Check for conflicts or unmerged paths
if echo "$STATUS_OUTPUT" | grep -q "^UU\|^AA\|^DD\|^AU\|^UA\|^DU\|^UD"; then
    echo -e "${RED}Error: Repository has conflicts or unmerged paths${NC}"
    echo "Please resolve conflicts before staging"
    exit 1
fi

# Function to classify a file into a bucket
classify_file() {
    local file="$1"
    local basename=$(basename "$file")
    local dirname=$(dirname "$file")

    # deps: lockfiles, dependency manifests
    if [[ "$basename" =~ ^(package-lock\.json|yarn\.lock|pnpm-lock\.yaml|Gemfile\.lock|Pipfile\.lock|poetry\.lock|Cargo\.lock|composer\.lock|go\.sum|mix\.lock|pubspec\.lock)$ ]] || \
       [[ "$basename" =~ ^(package\.json|Gemfile|Pipfile|pyproject\.toml|Cargo\.toml|composer\.json|go\.mod|mix\.exs|pubspec\.yaml|requirements\.txt|requirements-dev\.txt)$ ]]; then
        echo "deps"
        return
    fi

    # ci: GitHub/GitLab configs, pipelines
    if [[ "$file" =~ ^\.github/ ]] || \
       [[ "$file" =~ ^\.gitlab-ci\.yml$ ]] || \
       [[ "$file" =~ ^\.circleci/ ]] || \
       [[ "$file" =~ ^\.travis\.yml$ ]] || \
       [[ "$file" =~ ^azure-pipelines\.yml$ ]] || \
       [[ "$file" =~ ^\.buildkite/ ]] || \
       [[ "$file" =~ ^[Jj]enkinsfile$ ]]; then
        echo "ci"
        return
    fi

    # docs: README, docs, markdown
    if [[ "$basename" =~ ^README ]] || \
       [[ "$file" =~ ^docs/ ]] || \
       [[ "$file" =~ \.md$ ]] || \
       [[ "$file" =~ ^CHANGELOG ]] || \
       [[ "$file" =~ ^CONTRIBUTING ]] || \
       [[ "$file" =~ ^LICENSE ]]; then
        echo "docs"
        return
    fi

    # tests: test files and fixtures
    if [[ "$basename" =~ ^test_ ]] || \
       [[ "$basename" =~ _test\. ]] || \
       [[ "$basename" =~ \.test\. ]] || \
       [[ "$basename" =~ \.spec\. ]] || \
       [[ "$file" =~ /__tests__/ ]] || \
       [[ "$file" =~ /tests?/ ]] || \
       [[ "$file" =~ /spec/ ]] || \
       [[ "$file" =~ /fixtures?/ ]] || \
       [[ "$dirname" =~ (^|/)tests?$ ]] || \
       [[ "$dirname" =~ (^|/)__tests__$ ]] || \
       [[ "$dirname" =~ (^|/)spec$ ]]; then
        echo "tests"
        return
    fi

    # config: yaml/json/toml/ini, docker, k8s, helm
    if [[ "$basename" =~ \.(yaml|yml|json|toml|ini|conf|cfg|config)$ ]] || \
       [[ "$basename" =~ ^Dockerfile ]] || \
       [[ "$basename" =~ ^docker-compose ]] || \
       [[ "$file" =~ ^\.?k8s/ ]] || \
       [[ "$file" =~ ^helm/ ]] || \
       [[ "$file" =~ ^charts/ ]] || \
       [[ "$basename" =~ \.dockerignore$ ]] || \
       [[ "$basename" =~ ^\.env ]] || \
       [[ "$basename" =~ ^\.editorconfig$ ]] || \
       [[ "$basename" =~ ^\.gitignore$ ]] || \
       [[ "$basename" =~ ^\.gitattributes$ ]] || \
       [[ "$basename" =~ ^\.pre-commit-config\.yaml$ ]] || \
       [[ "$basename" =~ ^\.yamllint$ ]]; then
        echo "config"
        return
    fi

    # src: application/runtime code
    if [[ "$file" =~ \.(py|js|ts|jsx|tsx|java|go|rs|rb|php|c|cpp|h|hpp|cs|swift|kt|scala|clj|ex|exs|erl|hs|ml|fs|r|jl|lua|pl|sh|bash|zsh)$ ]]; then
        echo "src"
        return
    fi

    # misc: fallback
    echo "misc"
}

# Bash 3.2 compatible bucket storage (using functions instead of associative arrays)
# Initialize bucket storage
_bucket_deps=""
_bucket_src=""
_bucket_tests=""
_bucket_docs=""
_bucket_ci=""
_bucket_config=""
_bucket_misc=""

# Helper functions to get/set bucket values (bash 3.2 compatible)
get_bucket_files() {
    local bucket="$1"
    eval echo "\$_bucket_${bucket}"
}

set_bucket_files() {
    local bucket="$1"
    local value="$2"
    eval "_bucket_${bucket}=\"\$value\""
}

append_bucket_file() {
    local bucket="$1"
    local file="$2"
    local current=$(get_bucket_files "$bucket")
    if [ -n "$current" ]; then
        set_bucket_files "$bucket" "${current}|${file}"
    else
        set_bucket_files "$bucket" "$file"
    fi
}

get_bucket_count() {
    local bucket="$1"
    local files=$(get_bucket_files "$bucket")
    if [ -z "$files" ]; then
        echo "0"
    else
        echo "$files" | tr '|' '\n' | wc -l | tr -d ' '
    fi
}

# Parse git status and classify files
while IFS= read -r line; do
    # Extract file path (handle renames, copies, etc.)
    status="${line:0:2}"
    file="${line:3}"

    # Handle renamed files (R  old -> new)
    if [[ "$status" =~ ^R ]]; then
        file=$(echo "$file" | sed 's/^.* -> //')
    fi

    # Skip empty lines
    [ -z "$file" ] && continue

    # Classify and add to bucket
    bucket=$(classify_file "$file")
    append_bucket_file "$bucket" "$file"
done <<< "$STATUS_OUTPUT"

# Function to stage a bucket
stage_bucket() {
    local bucket="$1"
    local files=$(get_bucket_files "$bucket")

    if [ -z "$files" ]; then
        return
    fi

    # Convert pipe-separated list to array
    IFS='|' read -ra file_array <<< "$files"

    # Stage files
    for file in "${file_array[@]}"; do
        git add -- "$file"
    done

    local count=$(get_bucket_count "$bucket")
    echo -e "${GREEN}✓ Staged ${count} file(s) from bucket: $bucket${NC}"
}

# Execute based on mode
if [ "$MODE" = "all" ]; then
    # Stage all
    echo -e "${BLUE}Staging all changes...${NC}"
    git add -A
    echo -e "${GREEN}✓ All changes staged${NC}"

elif [ "$MODE" = "specific" ]; then
    # Stage specific bucket
    local bucket_files=$(get_bucket_files "$TARGET_BUCKET")
    local bucket_count=$(get_bucket_count "$TARGET_BUCKET")
    
    if [ -z "$bucket_files" ] || [ "$bucket_count" -eq 0 ]; then
        echo -e "${YELLOW}No files in bucket: $TARGET_BUCKET${NC}"
        exit 0
    fi

    echo -e "${BLUE}Staging bucket: $TARGET_BUCKET (${bucket_count} file(s))${NC}"
    stage_bucket "$TARGET_BUCKET"

else
    # Guided mode
    echo -e "${BLUE}Guided staging mode${NC}"
    echo ""

    # Present buckets in deterministic order
    for bucket in deps src config tests ci docs misc; do
        local count=$(get_bucket_count "$bucket")

        if [ "$count" -eq 0 ]; then
            continue
        fi

        echo -e "${YELLOW}Bucket: $bucket ($count file(s))${NC}"

        # Show files in bucket (first 5)
        local files=$(get_bucket_files "$bucket")
        IFS='|' read -ra file_array <<< "$files"
        local show_count=$((count < 5 ? count : 5))
        local i=0
        while [ $i -lt $show_count ]; do
            echo "  - ${file_array[$i]}"
            i=$((i + 1))
        done
        if [ "$count" -gt 5 ]; then
            echo "  ... and $((count - 5)) more"
        fi

        # Prompt user
        read -p "Stage this bucket? (y/n): " -n 1 -r
        echo ""

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            stage_bucket "$bucket"
        else
            echo -e "${YELLOW}✗ Skipped bucket: $bucket${NC}"
        fi

        echo ""
    done
fi

# Show post-staging output
echo ""
echo -e "${BLUE}=== Staged Changes (diff --cached --stat) ===${NC}"
git diff --cached --stat

echo ""
echo -e "${BLUE}=== Repository Status (status --porcelain) ===${NC}"
git status --porcelain

echo ""
echo -e "${GREEN}Done!${NC}"
