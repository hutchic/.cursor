#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# vim: set ft=bash:
#
# /gship - Branch + Semantic Commit Command
#
# Creates feature branches from protected branches and commits staged changes
# with semantic commit messages. Never bypasses hooks or signing.
#
# Usage:
#   gship <semantic-message> [--mode=single|multi]
#
# Examples:
#   gship "feat(api): add search endpoint"
#   gship "fix: resolve null pointer in handler"
#   gship "docs: update installation guide"
#   gship "feat(auth): add OAuth support" --mode=multi

set -euo pipefail

# Global variables
WORKING_BRANCH=""
COMMIT_HASH=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Protected branch patterns
PROTECTED_BRANCHES=("main" "master" "trunk" "develop")

# Function to print colored output
print_error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_info() {
    echo -e "${BLUE}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

# Function to check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Not in a git repository"
        exit 1
    fi
}

# Function to check for staged changes
check_staged_changes() {
    local staged_files
    staged_files=$(git diff --cached --name-only)
    
    if [ -z "$staged_files" ]; then
        print_error "No staged changes found"
        print_info "Please stage your changes first with 'git add' or '/gadd'"
        exit 1
    fi
    
    echo "$staged_files"
}

# Function to get current branch name
get_current_branch() {
    git symbolic-ref --short HEAD 2>/dev/null || echo "HEAD"
}

# Function to check if current branch is protected
is_protected_branch() {
    local current_branch="$1"
    
    # Check if HEAD is detached
    if [ "$current_branch" = "HEAD" ]; then
        return 0
    fi
    
    # Check against protected patterns
    for pattern in "${PROTECTED_BRANCHES[@]}"; do
        if [ "$current_branch" = "$pattern" ]; then
            return 0
        fi
    done
    
    # Check for release/* pattern
    if [[ "$current_branch" =~ ^release/ ]]; then
        return 0
    fi
    
    return 1
}

# Function to normalize branch name from semantic message
# Input: "feat(api): add search endpoint"
# Output: "feat/api-add-search-endpoint"
normalize_branch_name() {
    local message="$1"
    local branch_name
    
    # Extract type, scope, and summary
    # Pattern: type(scope): summary or type: summary
    if [[ "$message" =~ ^([a-z]+)\(([^\)]+)\):[[:space:]]*(.+)$ ]]; then
        local type="${BASH_REMATCH[1]}"
        local scope="${BASH_REMATCH[2]}"
        local summary="${BASH_REMATCH[3]}"
        branch_name="${type}/${scope}-${summary}"
    elif [[ "$message" =~ ^([a-z]+):[[:space:]]*(.+)$ ]]; then
        local type="${BASH_REMATCH[1]}"
        local summary="${BASH_REMATCH[2]}"
        branch_name="${type}/${summary}"
    else
        print_error "Invalid semantic message format"
        print_info "Expected: 'type(scope): summary' or 'type: summary'"
        print_info "Example: 'feat(api): add search' or 'fix: resolve bug'"
        exit 1
    fi
    
    # Lowercase
    branch_name=$(echo "$branch_name" | tr '[:upper:]' '[:lower:]')
    
    # Replace non-alphanumeric with hyphens
    branch_name=$(echo "$branch_name" | sed 's/[^a-z0-9/-]/-/g')
    
    # Collapse duplicate hyphens
    branch_name=$(echo "$branch_name" | sed 's/-\+/-/g')
    
    # Remove leading/trailing hyphens
    branch_name=$(echo "$branch_name" | sed 's/^-//;s/-$//')
    
    echo "$branch_name"
}

# Function to create branch if needed
# Sets global variable: WORKING_BRANCH
create_branch_if_needed() {
    local current_branch="$1"
    local semantic_message="$2"
    
    if is_protected_branch "$current_branch"; then
        local new_branch
        new_branch=$(normalize_branch_name "$semantic_message")
        
        print_info "Current branch '$current_branch' is protected"
        print_info "Creating new branch: $new_branch"
        
        if git show-ref --verify --quiet "refs/heads/$new_branch"; then
            print_error "Branch '$new_branch' already exists"
            print_info "Please use a different semantic message or switch to the existing branch"
            exit 1
        fi
        
        git checkout -b "$new_branch" > /dev/null 2>&1
        print_success "Created and switched to branch: $new_branch"
        WORKING_BRANCH="$new_branch"
    else
        print_info "Staying on current branch: $current_branch"
        WORKING_BRANCH="$current_branch"
    fi
}

# Function to validate semantic message format
validate_semantic_message() {
    local message="$1"
    
    # Valid semantic types
    local valid_types="feat|fix|docs|style|refactor|perf|test|chore|build|ci|revert"
    
    if [[ "$message" =~ ^($valid_types)(\([^\)]+\))?:[[:space:]]*(.+)$ ]]; then
        return 0
    else
        print_error "Invalid semantic commit format"
        print_info "Valid types: feat, fix, docs, style, refactor, perf, test, chore, build, ci, revert"
        print_info "Format: 'type(scope): summary' or 'type: summary'"
        print_info "Example: 'feat(api): add search' or 'fix: resolve bug'"
        exit 1
    fi
}

# Function to create a single commit
# Sets global variable: COMMIT_HASH
create_commit() {
    local message="$1"
    
    print_info "Creating commit with message: $message"
    
    # Use plain git commit with no bypass flags
    if git commit -m "$message"; then
        COMMIT_HASH=$(git rev-parse --short HEAD)
        print_success "Created commit: $COMMIT_HASH $message"
    else
        print_error "Commit failed"
        print_info "This could be due to:"
        print_info "  - Pre-commit hooks failing"
        print_info "  - GPG signing issues"
        print_info "  - Other git errors"
        exit 1
    fi
}

# Function to handle multi-commit mode
handle_multi_commit() {
    local semantic_message="$1"
    
    print_warning "Multi-commit mode is not yet fully implemented"
    print_info "Falling back to single-commit mode"
    
    create_commit "$semantic_message"
}

# Function to print summary
print_summary() {
    local branch="$1"
    local commit_hash="$2"
    local message="$3"
    
    echo ""
    print_success "=== Commit Summary ==="
    echo "Branch: $branch"
    echo "Commits:"
    echo "  - $commit_hash $message"
    echo ""
}

# Main function
main() {
    # Check if we're in a git repository
    check_git_repo
    
    # Parse arguments
    local semantic_message=""
    local mode="single"
    
    for arg in "$@"; do
        if [[ "$arg" =~ ^--mode= ]]; then
            mode="${arg#--mode=}"
        else
            semantic_message="$arg"
        fi
    done
    
    # Validate arguments
    if [ -z "$semantic_message" ]; then
        print_error "Missing semantic commit message"
        print_info "Usage: gship <semantic-message> [--mode=single|multi]"
        print_info "Example: gship \"feat(api): add search endpoint\""
        exit 1
    fi
    
    # Validate mode
    if [ "$mode" != "single" ] && [ "$mode" != "multi" ]; then
        print_error "Invalid mode: $mode"
        print_info "Valid modes: single, multi"
        exit 1
    fi
    
    # Validate semantic message format
    validate_semantic_message "$semantic_message"
    
    # Check for staged changes
    print_info "Checking for staged changes..."
    local staged_files
    staged_files=$(check_staged_changes)
    local file_count
    file_count=$(echo "$staged_files" | wc -l)
    print_success "Found $file_count staged file(s)"
    
    # Get current branch
    local current_branch
    current_branch=$(get_current_branch)
    print_info "Current branch: $current_branch"
    
    # Create branch if needed
    create_branch_if_needed "$current_branch" "$semantic_message"
    
    # Create commit(s)
    if [ "$mode" = "multi" ]; then
        handle_multi_commit "$semantic_message"
    else
        create_commit "$semantic_message"
    fi
    
    # Print summary
    print_summary "$WORKING_BRANCH" "$COMMIT_HASH" "$semantic_message"
    
    print_success "Done!"
}

# Run main function
main "$@"
